agents:
  changeset_analyzer:
    model: deepseek:deepseek-chat
    system_prompt: |
      You are a changeset analyzer for a monorepo using changesets.

      Your task is to:
      1. Analyze PR changes to determine which packages are affected
      2. Determine the appropriate version bump type (patch/minor/major) based on:
         - Commit messages (conventional commits: fix/feat/BREAKING CHANGE)
         - PR description and title
         - Code changes (API changes, breaking changes)
      3. Generate and commit changeset file to main branch

      Guidelines:
      - patch: bug fixes, documentation, internal refactors
      - minor: new features, new exports (backward compatible)
      - major: breaking changes, removed APIs, changed behavior
      - Look for keywords: "BREAKING", "breaking change", "feat:", "fix:", etc.
      - Multiple packages can be affected by one PR
      - If no changeset is needed (e.g., docs only, config only), say so explicitly

      Output format:
      1. Analysis summary (which packages, what type of change)
      2. Bash commands to create changeset, update versions, and create PR

      Important:
      - Only generate changeset if code changes affect published packages
      - Skip if changes are only in .github/, docs/, or config files
      - Use the standard changeset format
      - Commit changeset file directly to main branch
      - The release workflow will automatically detect the changeset and create a version PR

context:
  provider: memory

setup:
  # Get the merged PR number from the merge commit
  - shell: |
      if [ -z "$PR_NUMBER" ]; then
        # Extract PR number from merge commit message
        PR_NUMBER=$(git log -1 --pretty=%B | grep -oP '#\K\d+' | head -1)
        if [ -z "$PR_NUMBER" ]; then
          echo "Error: Could not determine PR number"
          exit 1
        fi
        echo "$PR_NUMBER"
      else
        echo "$PR_NUMBER"
      fi
    as: pr_number

  # Get PR information
  - shell: |
      gh pr view "${{ pr_number }}" --repo "$GITHUB_REPOSITORY" \
        --json title,body,author,labels,commits \
        --jq '{
          title: .title,
          body: .body,
          author: .author.login,
          labels: [.labels[].name],
          commits: [.commits[] | {message: .messageHeadline, body: .messageBody}]
        }'
    as: pr_info

  # Get changed files
  - shell: |
      gh pr view "${{ pr_number }}" --repo "$GITHUB_REPOSITORY" \
        --json files --jq '.files[].path'
    as: changed_files

  # Get PR diff
  - shell: |
      gh pr diff "${{ pr_number }}" --repo "$GITHUB_REPOSITORY"
    as: pr_diff

  # Check for existing changesets in the merged PR
  - shell: |
      CHANGESETS=$(gh pr view "${{ pr_number }}" --repo "$GITHUB_REPOSITORY" \
        --json files --jq '.files[] | select(.path | startswith(".changeset/")) | .path')

      if [ -n "$CHANGESETS" ]; then
        echo "Existing changesets found:"
        echo "$CHANGESETS"
        echo "has_changeset=true"
      else
        echo "No changesets found in PR"
        echo "has_changeset=false"
      fi
    as: existing_changesets

  # List packages in monorepo
  - shell: |
      if [ -f "package.json" ]; then
        if grep -q '"workspaces"' package.json; then
          # Extract package names from workspaces
          for pkg_dir in packages/*/package.json; do
            if [ -f "$pkg_dir" ]; then
              jq -r '.name' "$pkg_dir" 2>/dev/null
            fi
          done
        fi
      fi
    as: packages

kickoff: |
  @changeset_analyzer Analyze this merged PR to determine if a changeset should be generated.

  ## PR Information
  ```json
  ${{ pr_info }}
  ```

  ## Changed Files
  ```
  ${{ changed_files }}
  ```

  ## Existing Changesets
  ```
  ${{ existing_changesets }}
  ```

  ## Available Packages
  ```
  ${{ packages }}
  ```

  ## PR Diff (first 5000 chars)
  ```diff
  ${{ pr_diff }}
  ```

  ## Task

  1. **Check if changeset is needed**:
     - If `has_changeset=true` in existing changesets, STOP - changeset already exists
     - If changes only affect non-package code (.github/, docs/, root config), STOP - no changeset needed
     - Otherwise, proceed to generate changeset

  2. **Analyze the changes**:
     - Which packages are affected? (check changed_files against packages/)
     - What type of change? (patch/minor/major)
     - Evidence: commit messages, PR title/body, code diff

  3. **Generate changeset** (if needed):
     - Create a properly formatted changeset file
     - Use a timestamp-based filename for uniqueness
     - Follow the changeset format:
       ```
       ---
       "package-name": patch|minor|major
       ---

       Description of the change
       ```

  4. **Execute commands** (if changeset is needed):
     ```bash
     # Generate a unique changeset ID
     CHANGESET_ID="auto-$(date +%Y%m%d-%H%M%S)"

     # Create changeset file with proper format
     cat > .changeset/${CHANGESET_ID}.md << 'EOF'
     ---
     "package-name": patch|minor|major
     ---

     Brief description of the change (from PR title/commits)
     EOF

     # Commit directly to main branch
     git add .changeset/${CHANGESET_ID}.md
     git commit -m "chore: add changeset for PR #${{ pr_number }}"
     git push origin main
     ```

  **Important**:
  - Only proceed if changeset is actually needed (no existing changeset + package code changed)
  - Use correct package names from the packages list
  - Provide detailed reasoning in your analysis
  - Include the PR title/description context in the changeset
  - Execute all bash commands using the Bash tool
  - The changeset file will be committed directly to main
  - The existing release workflow will automatically:
    - Detect the new changeset file
    - Create/update a "Version Packages" PR with version updates
    - Publish packages when that PR is merged
  - If any command fails, report the error clearly and stop
